package server

import (
	"fmt"
	"library-management-system/database"
	"library-management-system/server/queries"
	"library-management-system/utils"
	"math/rand"
	"os"
	"slices"
	"sort"
	"strings"
	"testing"

	"github.com/go-playground/assert/v2"
	"gopkg.in/yaml.v3"
)

type AppConfig struct {
	Server   Config          `yaml:"server"`
	Database database.Config `yaml:"database"`
}

func TestMain(m *testing.M) {
	file, err := os.Open("../config.yaml")
	if err != nil {
		fmt.Println("Failed to open config file: ", err)
		return
	}
	defer func(file *os.File) {
		err := file.Close()
		if err != nil {
			fmt.Println("Failed to close config file: ", err)
		}
	}(file)

	var config AppConfig
	if err := yaml.NewDecoder(file).Decode(&config); err != nil {
		fmt.Println("Failed to parse config file: ", err)
		return
	}

	database.ConnectDatabase(config.Database)
	m.Run()
}

func TestBookRegister(t *testing.T) {
	server := Server{}
	database.ResetDatabase()

	b0 := database.Book{
		Category: "Computer Science", Title: "Database System Concepts",
		Press: "Machine Industry Press", PublishYear: 2023,
		Author: "Mike", Price: 188.88, Stock: 10,
	}
	assert.Equal(t, server.StoreBook(&b0).Ok, true)

	/* Not allowed to create duplicated records */
	b1 := database.Book{
		Category: "Computer Science", Title: "Database System Concepts",
		Press: "Machine Industry Press", PublishYear: 2023,
		Author: "Mike", Price: 188.88, Stock: 5,
	}
	b2 := database.Book{
		Category: "Computer Science", Title: "Database System Concepts",
		Press: "Machine Industry Press", PublishYear: 2023,
		Author: "Mike", Price: 99.99, Stock: 10,
	}
	assert.Equal(t, server.StoreBook(&b1).Ok, false)
	assert.Equal(t, server.StoreBook(&b2).Ok, false)

	/* check equal function */
	// records all books generated by test case, include duplicate book
	originBookList := []*database.Book{&b0, &b1, &b2}
	// records which books should exist in database
	actualBookList := make(utils.BookSet)
	actualBookList.InsertPtr(&b0) // b0 already inserted to database
	// corresponding to originBookList, mark whether a book is duplicated
	bookValid := []bool{false, false, false} // b0 already inserted to database, so bookValid[0] is false
	// Check the books
	for i, book := range originBookList {
		if actualBookList.Contains(*book) {
			assert.Equal(t, bookValid[i], false)
		} else {
			actualBookList.InsertPtr(book)
			assert.Equal(t, bookValid[i], true)
		}
	}
	assert.Equal(t, 1, len(actualBookList))

	/* Generate some books */
	for i := 0; i < 50; i++ {
		b := utils.RandomBook()
		originBookList = append(originBookList, &b)
		if actualBookList.Contains(b) {
			bookValid = append(bookValid, false)
		} else {
			actualBookList.InsertPtr(&b)
			bookValid = append(bookValid, true)
		}
	}
	assert.Equal(t, len(originBookList), len(bookValid))
	assert.Equal(t, len(originBookList) > len(actualBookList), true)

	/* generate some duplicate books */
	for i := 0; i < 10; i++ {
		dupIndex := rand.Intn(len(originBookList))
		ob := originBookList[dupIndex]
		if bookValid[i] {
			assert.Equal(t, actualBookList.Contains(*ob), true)
			cb := *ob
			// randomly change some attributes
			if rand.Intn(2) == 0 {
				cb.Stock = utils.RandomStock()
				cb.Price = utils.RandomPrice()
			}
			assert.Equal(t, actualBookList.Contains(cb), true)
			originBookList = append(originBookList, &cb)
			bookValid = append(bookValid, false)
		}
	}
	assert.Equal(t, len(originBookList), len(bookValid))
	assert.Equal(t, len(originBookList) > len(actualBookList), true)

	/* Bulk load these books */
	for i, book := range originBookList {
		if bookValid[i] {
			assert.Equal(t, server.StoreBook(book).Ok, true)
		} else {
			assert.Equal(t, server.StoreBook(book).Ok, false)
		}
	}

	/* Use query interface to check correctness */
	queryResult := server.QueryBooks(queries.BookQueryConditions{})
	assert.Equal(t, queryResult.Ok, true)
	selectedResults := queryResult.Payload.(queries.BookQueryResults)
	assert.Equal(t, len(selectedResults.Results), selectedResults.Count)

	// Sort actual book list by its PK
	compareBooks := actualBookList.List()
	sort.Slice(compareBooks, func(i, j int) bool {
		return compareBooks[i].BookId < compareBooks[j].BookId
	})

	assert.Equal(t, len(compareBooks), selectedResults.Count)
	for i := 0; i < len(compareBooks); i++ {
		// Pointer and Value comparison: just compare the value
		assert.Equal(t, compareBooks[i], selectedResults.Results[i])
	}
}

func TestIncBookStock(t *testing.T) {
	server := Server{}
	database.ResetDatabase()

	const numBooks = 50
	const numRandomTests = 1000
	/* simply insert some books to database */
	database.ResetDatabase()
	var books = make(map[database.Book]int) // Use map to avoid duplicated books
	var bookIds = make(map[int]int)
	for i := 0; i < numBooks; i++ {
		book := utils.RandomBook()
		books[book] = i
	}

	var bookList = make([]*database.Book, 0, len(books))
	for book, i := range books {
		result := server.StoreBook(&book)
		assert.Equal(t, result.Ok, true)
		bookIds[result.Payload.(*database.Book).BookId] = i
		bookList = append(bookList, &book)
	}
	assert.Equal(t, len(books), len(bookIds))

	/* begin tests */
	type args struct {
		bookId     int
		deltaStock int
	}
	type test struct {
		name string
		args args
		want database.APIResult
	}
	var tests []test

	/* corner case: invalid book id */
	tests = append(tests, test{
		name: "Invalid book id - Negative",
		args: args{bookId: -1, deltaStock: 6},
		want: database.APIResult{Ok: false},
	})
	k := len(books) + 1
	_, ok := bookIds[k]
	for ok { // generate an invalid book id
		k++
		_, ok = bookIds[k]
	}
	tests = append(tests, test{
		name: "Invalid book id - Maximum",
		args: args{bookId: k, deltaStock: 10},
		want: database.APIResult{Ok: false},
	})

	/* corner case: invalid book stock */
	lastBook := bookList[len(bookList)-1]
	tests = append(tests, test{
		name: "Decrease book stock",
		args: args{bookId: lastBook.BookId, deltaStock: -lastBook.Stock},
		want: database.APIResult{Ok: true},
	})
	tests = append(tests, test{
		name: "Increase book stock",
		args: args{bookId: lastBook.BookId, deltaStock: 1},
		want: database.APIResult{Ok: true},
	})
	tests = append(tests, test{
		name: "Test for invalid book stock - Negative",
		args: args{bookId: lastBook.BookId, deltaStock: -2},
		want: database.APIResult{Ok: false},
	})
	lastBook.Stock = 1

	/* randomly choose some books to do this operation */
	for i := 0; i < numRandomTests; i++ {
		book := bookList[rand.Intn(len(bookList)-1)]
		assert.NotEqual(t, book, nil)
		deltaStock := rand.Intn(24) - 8
		expected := book.Stock+deltaStock >= 0
		if expected {
			book.Stock = book.Stock + deltaStock
		}
		tests = append(tests, test{
			name: fmt.Sprintf("Random test %d", i),
			args: args{bookId: book.BookId, deltaStock: deltaStock},
			want: database.APIResult{Ok: expected},
		})
	}

	/* run tests */
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := server.IncBookStock(tt.args.bookId, tt.args.deltaStock); got.Ok != tt.want.Ok {
				t.Errorf("IncBookStock() = %v, want %v", got, tt.want)
			}
		})
	}

	/* use query interface to check correctness */
	sort.Slice(bookList, func(i, j int) bool {
		return bookList[i].BookId < bookList[j].BookId
	})
	queryResult := server.QueryBooks(queries.BookQueryConditions{})
	assert.Equal(t, queryResult.Ok, true)
	selectedResults := queryResult.Payload.(queries.BookQueryResults)
	assert.Equal(t, len(bookList), selectedResults.Count)
	for i := 0; i < len(bookList); i++ {
		assert.Equal(t, bookList[i], selectedResults.Results[i])
	}
}

func TestBulkRegisterBook(t *testing.T) {
	const numBulkBooks = 1000
	const numDuplicateBooks = 3
	server := Server{}
	database.ResetDatabase()

	/* simply insert some books to database */
	var books = make(utils.BookSet)
	for i := 0; i < numBulkBooks; i++ {
		book := utils.RandomBook()
		books.Insert(book)
	}

	/* provide some duplicate records */
	bookList1 := books.List()
	for i := 0; i < numDuplicateBooks; i++ {
		newBook := *bookList1[rand.Intn(len(bookList1))]
		cb := &newBook
		// randomly change some attributes
		if rand.Intn(2) == 0 {
			cb.Stock = utils.RandomStock()
			cb.Price = utils.RandomPrice()
		}
		bookList1 = append(bookList1, cb)
	}
	// shuffle the book list
	rand.Shuffle(len(bookList1), func(i, j int) {
		bookList1[i], bookList1[j] = bookList1[j], bookList1[i]
	})
	assert.Equal(t, server.StoreBooks(bookList1).Ok, false)

	/* make sure that none of the books are inserted */
	queryResult1 := server.QueryBooks(queries.BookQueryConditions{})
	assert.Equal(t, queryResult1.Ok, true)
	selectedResults1 := queryResult1.Payload.(queries.BookQueryResults)
	assert.Equal(t, 0, selectedResults1.Count)

	/* normal batch insert */
	bookList2 := books.List()
	assert.Equal(t, server.StoreBooks(bookList2).Ok, true)
	queryResult2 := server.QueryBooks(queries.BookQueryConditions{})
	assert.Equal(t, queryResult2.Ok, true)
	selectedResults2 := queryResult2.Payload.(queries.BookQueryResults)
	assert.Equal(t, len(bookList2), selectedResults2.Count)
	sort.Slice(bookList2, func(i, j int) bool {
		return bookList2[i].BookId < bookList2[j].BookId
	})
	for i := 0; i < len(bookList2); i++ {
		assert.Equal(t, bookList2[i], selectedResults2.Results[i])
	}
}

func TestRemoveBook(t *testing.T) {
	server := Server{}
	database.ResetDatabase()

	/* simply insert some data to database */
	library := utils.CreateLibrary(100, 1, 0, &server)
	/* remove a non-exist book */
	assert.Equal(t, server.RemoveBook(-1).Ok, false)

	/* remove a book that someone has not returned yet */
	borrow := database.CreateBorrow(library.Cards[0].CardId, library.Books[0].BookId)
	borrow.ResetBorrowTime()
	assert.Equal(t, server.BorrowBook(borrow).Ok, true)
	assert.Equal(t, server.RemoveBook(library.Books[0].BookId).Ok, false)
	borrow.ResetReturnTime()
	assert.Equal(t, server.ReturnBook(borrow).Ok, true)
	assert.Equal(t, server.RemoveBook(library.Books[0].BookId).Ok, true)

	/* remove a non-exist book */
	assert.Equal(t, server.RemoveBook(library.Books[0].BookId).Ok, false)
	library.Books = library.Books[1:]

	/* randomly choose nRemove books to remove */
	nRemove := rand.Intn(40) + 10
	for i := 0; i < nRemove; i++ {
		assert.Equal(t, server.RemoveBook(library.Books[0].BookId).Ok, true)
		/* remove a non-exist book */
		assert.Equal(t, server.RemoveBook(library.Books[0].BookId).Ok, false)
		library.Books = library.Books[1:]
	}

	/* compare results */
	queryResult1 := server.QueryBooks(queries.BookQueryConditions{})
	assert.Equal(t, queryResult1.Ok, true)
	selectedResults1 := queryResult1.Payload.(queries.BookQueryResults)
	assert.Equal(t, len(library.Books), selectedResults1.Count)

	sort.Slice(library.Books, func(i, j int) bool {
		return library.Books[i].BookId < library.Books[j].BookId
	})
	for i := 0; i < len(library.Books); i++ {
		assert.Equal(t, library.Books[i], selectedResults1.Results[i])
	}
}

func TestModifyBookInfo(t *testing.T) {
	server := Server{}
	database.ResetDatabase()

	/* simply insert some books to database */
	books := make(utils.BookSet)
	for i := 0; i < 100; i++ {
		books.Insert(utils.RandomBook())
	}
	bookList := books.List()
	for _, book := range bookList {
		assert.Equal(t, server.StoreBook(book).Ok, true)
	}
	/* randomly change books */
	for _, book := range bookList {
		// remove old book from book set
		assert.Equal(t, books.Remove(*book), true)
		oldStock := book.Stock      // book's stock cannot be changed by modifyBookInfo
		for books.Contains(*book) { // make sure the new book does not exist in database
			// use bit mask to determine which field to update
			var mask = rand.Intn(128)
			if mask&0b0000_0001 > 0 {
				book.Category = utils.RandomCategory()
			}
			if mask&0b0000_0010 > 0 {
				book.Title = utils.RandomTitle()
			}
			if mask&0b0000_0100 > 0 {
				book.Press = utils.RandomPress()
			}
			if mask&0b0000_1000 > 0 {
				book.PublishYear = utils.RandomPublishYear()
			}
			if mask&0b0001_0000 > 0 {
				book.Author = utils.RandomAuthor()
			}
			if mask&0b0010_0000 > 0 {
				book.Price = utils.RandomPrice()
			}
			if mask&0b0100_0000 > 0 {
				book.Stock = utils.RandomStock()
			}
		}
		// insert new book to book set
		books.Insert(*book)
		assert.Equal(t, server.ModifyBookInfo(book).Ok, true)
		book.Stock = oldStock
	}
	// compare results
	queryResult := server.QueryBooks(queries.BookQueryConditions{})
	assert.Equal(t, queryResult.Ok, true)
	selectedResults := queryResult.Payload.(queries.BookQueryResults)
	assert.Equal(t, len(bookList), selectedResults.Count)
	bookList = books.List()
	sort.Slice(bookList, func(i, j int) bool {
		return bookList[i].BookId < bookList[j].BookId
	})
	for i := 0; i < len(bookList); i++ {
		assert.Equal(t, bookList[i], selectedResults.Results[i])
	}
}

func TestQueryBook(t *testing.T) {
	server := Server{}
	database.ResetDatabase()

	/* simply insert some books to database */
	my := utils.CreateLibrary(100, 1, 0, &server)
	/* generate single query condition */
	queryConditions := make([]queries.BookQueryConditions, 0)
	for i := 0; i < 15; i++ {
		queryConditions = append(queryConditions, queries.BookQueryConditions{})
	}
	queryConditions[0].Category = utils.RandomCategory()
	queryConditions[1].Title = utils.RandomTitle()
	queryConditions[2].Press = "Press" // test fuzzy matching
	queryConditions[3].Press = utils.RandomPress()
	queryConditions[4].MinPrice = utils.RandomPrice()
	queryConditions[5].MaxPrice = utils.RandomPrice()
	queryConditions[6].MinPrice = 20.24
	queryConditions[6].MaxPrice = 52.42
	queryConditions[7].MinPublishYear = 2008
	queryConditions[8].MaxPublishYear = 2020
	{
		minY := rand.Intn(15) + 2000
		maxY := max(minY, rand.Intn(17)+2007)
		queryConditions[9].MinPublishYear = minY
		queryConditions[9].MaxPublishYear = maxY
	}
	queryConditions[10].Author = "o" // test fuzzy matching
	queryConditions[11].Author = utils.RandomAuthor()
	queryConditions[12].SortBy = queries.Price
	queryConditions[12].SortOrder = queries.Asc
	queryConditions[13].SortBy = queries.Price
	queryConditions[13].SortOrder = queries.Desc
	queryConditions[14].SortBy = queries.PublishYear
	queryConditions[14].SortOrder = queries.Desc
	/* generate multi query conditions */
	for i := 0; i < 45; i++ {
		c := queries.BookQueryConditions{}
		mask := rand.Intn(32)
		selected := 0
		if (mask & 1) > 0 {
			c.Press = utils.RandomPress()
			selected++
		}
		if (mask & 2) > 0 {
			c.Category = utils.RandomCategory()
			selected++
		}
		if (mask & 4) > 0 {
			c.Author = utils.RandomAuthor()
			selected++
		}
		// Randomly select year
		if rand.Intn(2+selected) == 1 {
			minY := rand.Intn(15) + 2000
			maxY := max(rand.Intn(17)+2007, minY+7)
			c.MinPublishYear = minY
			c.MaxPublishYear = maxY
			selected++
		}
		// Randomly select price
		if rand.Intn(3+selected) == 1 {
			minP := utils.RandomPrice()
			maxP := max(utils.RandomPrice(), minP+16.66)
			c.MinPrice = minP
			c.MaxPrice = maxP
		}
		// Randomly choose one column to sort
		if rand.Intn(4) != 1 {
			c.SortBy = utils.RandomSortColumn()
			c.SortOrder = utils.RandomSortOrder()
		}
		queryConditions = append(queryConditions, c)
	}

	// Loop testing
	for _, queryCondition := range queryConditions {
		queryResult := server.QueryBooks(queryCondition)
		assert.Equal(t, queryResult.Ok, true)
		bookResults := queryResult.Payload.(queries.BookQueryResults)
		expectedResults := verifyQueryResult(my.Books, queryCondition)
		assert.Equal(t, len(expectedResults), bookResults.Count)
		for i := 0; i < len(expectedResults); i++ {
			assert.Equal(t, expectedResults[i], bookResults.Results[i])
		}
	}
}

func TestBorrowAndReturnBook(t *testing.T) {
	server := Server{}
	database.ResetDatabase()

	// Insert some books & cards & borrow histories to database
	my := utils.CreateLibrary(50, 50, 100, &server)

	// Borrow a non-exists book
	bookIds := make(map[int]bool)
	for _, book := range my.Books {
		bookIds[book.BookId] = true
	}
	stockMap := make(map[int]int)
	for _, book := range my.Books {
		stockMap[book.BookId] = book.Stock
	}
	nbId := rand.Intn(200)
	for bookIds[nbId] {
		nbId = rand.Intn(200)
	}
	cardIds := make(map[int]bool)
	for _, card := range my.Cards {
		cardIds[card.CardId] = true
	}
	nb := database.CreateBorrow(my.Cards[0].CardId, nbId)
	nb.ResetBorrowTime()
	nb.ResetReturnTime()
	assert.Equal(t, server.BorrowBook(nb).Ok, false)
	assert.Equal(t, server.ReturnBook(nb).Ok, false)

	// Card not exists
	ncId := rand.Intn(200)
	for cardIds[ncId] {
		ncId = rand.Intn(200)
	}
	nc := database.CreateBorrow(ncId, my.Books[0].BookId)
	nc.ResetBorrowTime()
	nc.ResetReturnTime()
	assert.Equal(t, server.BorrowBook(nc).Ok, false)
	assert.Equal(t, server.ReturnBook(nc).Ok, false)

	// Book & card both not exist
	nbc := database.CreateBorrow(ncId, nbId)
	nbc.ResetBorrowTime()
	assert.Equal(t, server.BorrowBook(nbc).Ok, false)

	// Borrow a book
	b0 := my.Books[rand.Intn(len(my.Books))]
	assert.Equal(t, b0.Stock > 0, true)
	c0 := my.Cards[rand.Intn(len(my.Cards))]
	r0 := database.CreateBorrow(c0.CardId, b0.BookId)
	r0.ResetBorrowTime()
	r0.ResetReturnTime()
	assert.Equal(t, server.ReturnBook(r0).Ok, false)
	assert.Equal(t, server.BorrowBook(r0).Ok, true)

	// Borrow it again
	r1 := database.CreateBorrow(c0.CardId, b0.BookId)
	r1.ResetBorrowTime()
	assert.Equal(t, server.BorrowBook(r1).Ok, false)

	// Return this book
	// Corner case, for return_time > borrow_time
	nt := database.CreateBorrow(c0.CardId, b0.BookId)
	nt.ReturnTime = 666
	assert.Equal(t, server.ReturnBook(nt).Ok, false)
	nt.ReturnTime = r0.BorrowTime
	assert.Equal(t, server.ReturnBook(nt).Ok, false)

	// Normal case
	r0.ResetReturnTime()
	assert.Equal(t, server.ReturnBook(r0).Ok, true)
	my.Borrows = append(my.Borrows, &r0) // Add to borrow list after operation

	// Return this book again
	r1.ResetReturnTime()
	assert.Equal(t, server.ReturnBook(r1).Ok, false)

	// Borrow & return this book
	r2 := database.CreateBorrow(c0.CardId, b0.BookId)
	r2.ResetBorrowTime()
	assert.Equal(t, server.BorrowBook(r2).Ok, true)
	r2.ResetReturnTime()
	assert.Equal(t, server.ReturnBook(r2).Ok, true)
	my.Borrows = append(my.Borrows, &r2) // Add to borrow list after operation

	// Try to borrow a zero-stock book
	assert.Equal(t, server.IncBookStock(b0.BookId, -b0.Stock).Ok, true)
	r3 := database.CreateBorrow(c0.CardId, b0.BookId)
	r3.ResetBorrowTime()
	assert.Equal(t, server.BorrowBook(r3).Ok, false)
	stockMap[b0.BookId] = 0 // Now b0.stock == 0

	// Randomly borrow & return books
	var borrowList []*database.Borrow
	type borrowRecord struct {
		bookId int
		CardId int
	}
	borrowStatus := make(map[borrowRecord]bool)
	for i := 0; i < 1000; i++ {
		if rand.Intn(2) == 0 && len(borrowList) > 0 { // Do return book
			k := rand.Intn(len(borrowList))
			r := borrowList[k]
			r.ResetReturnTime()
			assert.Equal(t, server.ReturnBook(*r).Ok, true)
			borrowList = append(borrowList[:k], borrowList[k+1:]...)
			delete(borrowStatus, borrowRecord{r.BookId, r.CardId})
			my.Borrows = append(my.Borrows, r) // Add to borrow list after operation
			stockMap[r.BookId]++
		} else { // Do borrow book
			b := my.Books[rand.Intn(len(my.Books))]
			c := my.Cards[rand.Intn(len(my.Cards))]
			r := database.CreateBorrow(c.CardId, b.BookId)
			r.ResetBorrowTime()
			sp := borrowRecord{r.BookId, r.CardId}
			if borrowStatus[sp] || stockMap[r.BookId] == 0 {
				assert.Equal(t, server.BorrowBook(r).Ok, false)
			} else {
				assert.Equal(t, server.BorrowBook(r).Ok, true)
				borrowStatus[sp] = true
				borrowList = append(borrowList, &r)
				stockMap[r.BookId]--
			}
		}
	}
	// Add un-returned books to borrow histories
	my.Borrows = append(my.Borrows, borrowList...)

	// Compare borrow histories
	bookMap := make(map[int]*database.Book)
	for _, book := range my.Books {
		bookMap[book.BookId] = book
	}
	// Card_id --> borrow_items
	expectedBorrowMap := make(map[int][]*database.Borrow)
	for _, borrow := range my.Borrows {
		item := borrow
		if _, ok := expectedBorrowMap[borrow.CardId]; !ok {
			expectedBorrowMap[borrow.CardId] = []*database.Borrow{}
		}
		expectedBorrowMap[borrow.CardId] = append(expectedBorrowMap[borrow.CardId], item)
	}
	for _, list := range expectedBorrowMap {
		sort.Slice(list, func(i, j int) bool {
			if list[i].BorrowTime == list[j].BorrowTime {
				return list[i].BookId < list[j].BookId
			}
			return list[i].BorrowTime > list[j].BorrowTime
		})
	}
	for _, card := range my.Cards {
		result := server.ShowBorrowHistories(card.CardId)
		assert.Equal(t, result.Ok, true)
		histories := result.Payload.(queries.BorrowHistories).Items
		expectedList := expectedBorrowMap[card.CardId]
		assert.Equal(t, len(expectedList), len(histories))
		for i := 0; i < len(expectedList); i++ {
			assert.Equal(t, expectedList[i], histories[i])
		}
	}
}

func TestParallelBorrowBook(t *testing.T) {
	const numGoroutines = 16
	server := Server{}
	database.ResetDatabase()

	// Insert some books & cards to database
	library := utils.CreateLibrary(1, numGoroutines, 0, &server)
	assert.Equal(t, server.IncBookStock(library.Books[0].BookId, -library.Books[0].Stock+1).Ok, true)

	// Create a channel to communicate between goroutines
	done := make(chan bool)
	success := make(chan bool, numGoroutines)

	// all goroutines connects to database
	for i := 0; i < numGoroutines; i++ {
		go func(i int) {
			// Each goroutine borrows a book using a different cardId
			borrow := database.CreateBorrow(library.Cards[i].CardId, 1)
			result := server.BorrowBook(borrow)
			if result.Ok {
				success <- true
			}

			// Signal that this goroutine is done
			done <- true
		}(i)
	}

	// Wait for all goroutines to finish
	for i := 0; i < numGoroutines; i++ {
		<-done
	}

	// Check if only one goroutine has successfully borrowed the book
	successCount := 0
	for i := 0; i < numGoroutines; i++ {
		select {
		case <-success:
			successCount++
		default:
		}
	}

	if successCount != 1 {
		t.Errorf("Expected 1 goroutine to successfully borrow the book, but got %d", successCount)
	}
}

func TestRegisterAndShowAndRemoveCard(t *testing.T) {
	const randomTimes = 20
	server := Server{}
	database.ResetDatabase()

	/* simply insert N cards */
	library := utils.CreateLibrary(1, 100, 0, &server)

	/* duplicate create */
	duplicateCard := *library.Cards[rand.Intn(len(library.Cards))]
	duplicateCard.CardId = 0
	assert.Equal(t, server.RegisterCard(&duplicateCard).Ok, false)

	/* delete a card that has some un-returned books */
	delPos := rand.Intn(library.NumCards())
	delCard := library.Cards[delPos]
	borrow := database.CreateBorrow(delCard.CardId, library.Books[0].BookId)
	borrow.ResetBorrowTime()
	assert.Equal(t, server.BorrowBook(borrow).Ok, true)
	assert.Equal(t, server.RemoveCard(delCard.CardId).Ok, false)
	borrow.ResetReturnTime()
	assert.Equal(t, server.ReturnBook(borrow).Ok, true)
	assert.Equal(t, server.RemoveCard(delCard.CardId).Ok, true)
	/* delete a non-exists card */
	assert.Equal(t, server.RemoveCard(-1).Ok, false)
	assert.Equal(t, server.RemoveCard(delCard.CardId).Ok, false)
	// delete this card from library
	library.Cards = append(library.Cards[:delPos], library.Cards[delPos+1:]...)

	/* randomly delete some cards */
	rand.Shuffle(len(library.Cards), func(i, j int) {
		library.Cards[i], library.Cards[j] = library.Cards[j], library.Cards[i]
	})
	for i := 0; i < randomTimes; i++ {
		dCard := library.Cards[0]
		assert.Equal(t, server.RemoveCard(dCard.CardId).Ok, true)
		assert.Equal(t, server.RemoveCard(dCard.CardId).Ok, false)
		library.Cards = library.Cards[1:]
	}

	/* check cards */
	sort.Slice(library.Cards, func(i, j int) bool {
		return library.Cards[i].CardId < library.Cards[j].CardId
	})
	result := server.ShowCards()
	assert.Equal(t, result.Ok, true)
	selectedResults := result.Payload.(queries.CardList)
	assert.Equal(t, len(library.Cards), selectedResults.Count)
	for i := 0; i < len(library.Cards); i++ {
		assert.Equal(t, library.Cards[i], selectedResults.Cards[i])
	}
}

func filter(arr []*database.Book, cond func(*database.Book) bool) []*database.Book {
	result := []*database.Book{}
	for _, v := range arr {
		if cond(v) {
			result = append(result, v)
		}
	}
	return result
}

func verifyQueryResult(books []*database.Book, conditions queries.BookQueryConditions) []*database.Book {
	var result []*database.Book
	for _, book := range books {
		result = append(result, book)
	}
	if conditions.Category != "" {
		result = filter(books, func(book *database.Book) bool {
			return book.Category == conditions.Category
		})
	}
	if conditions.Title != "" {
		result = filter(result, func(book *database.Book) bool {
			return strings.Contains(book.Title, conditions.Title)
		})
	}
	if conditions.Press != "" {
		result = filter(result, func(book *database.Book) bool {
			return strings.Contains(book.Press, conditions.Press)
		})
	}
	if conditions.MinPublishYear != 0 {
		result = filter(result, func(book *database.Book) bool {
			return book.PublishYear >= conditions.MinPublishYear
		})
	}
	if conditions.MaxPublishYear != 0 {
		result = filter(result, func(book *database.Book) bool {
			return book.PublishYear <= conditions.MaxPublishYear
		})
	}
	if conditions.Author != "" {
		result = filter(result, func(book *database.Book) bool {
			return strings.Contains(book.Author, conditions.Author)
		})
	}
	if conditions.MinPrice != 0 {
		result = filter(result, func(book *database.Book) bool {
			return book.Price >= conditions.MinPrice
		})
	}
	if conditions.MaxPrice != 0 {
		result = filter(result, func(book *database.Book) bool {
			return book.Price <= conditions.MaxPrice
		})
	}

	sortBy := queries.BookId
	if conditions.SortBy != "" {
		sortBy = conditions.SortBy
	}
	cmp := queries.BookComparator(queries.GetComparator(sortBy))
	if conditions.SortOrder == queries.Desc {
		cmp = cmp.Reverse()
	}
	cmp = cmp.ThenByIdAsc()
	slices.SortFunc(result, cmp)
	return result
}
